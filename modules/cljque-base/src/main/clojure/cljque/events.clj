(ns cljque.events
  (:refer-clojure :exclude (map filter take take-while merge)))

(defprotocol Observable
  (subscribe! [this f]
    "Invokes f for each event generated by this observable, whenever
    and wherever it occurs. The argument to f implements Observable,
    Subscription, and Observation. May have side effects. Returns a
    Subscription."))

(defprotocol Subscription
  (unsubscribe! [this]
    "Terminates this subscription. May have side effects, but must be
    idempotent."))

(defprotocol Observation
  (observe [this]
    "Returns this observation or nil if the end of observable events
    has been reached.")
  (accept [this]
    "Returns the latest event observed, or nil if the end of
    observable events has been reached. Re-throws exceptions thrown by
    the Observable source."))

(extend-type nil
  Observable
  (subscribe! [this f] (future (f nil)))
  Subscription
  (unsubscribe! [this] nil)
  Observation
  (observe [this] nil)
  (accept [this] nil))

(deftype ObservedEvent [event subscription]
  Observation
  (observe [this] this)
  (accept [this] event)
  Observable
  (subscribe! [this g]
    (subscribe! subscription g))
  Subscription
  (unsubscribe! [this]
    (unsubscribe! subscription)))

(deftype ObservedError [throwable]
  Observation
  (observe [this] this)
  (accept [this] (throw throwable)))

(deftype ObservableSeq [s]
  Observable
  (subscribe! [this f]
    (let [open? (atom true)
          sub (reify Subscription
                (unsubscribe! [this] (reset! open? false)))]
      (future
        (try
          (loop [xs s]
            (when (and @open? (seq xs))
              (let [event (try (ObservedEvent. (first xs) sub)
                               (catch Throwable t
                                 (ObservedError. t)))]
                (f event))
              (recur (next xs))))
          (when @open?
            (f nil))))
      sub)))

(declare ^:dynamic *observation* ^:dynamic *downstream*)

(deftype Lens [source f]
  Observable
  (subscribe! [this g]
    (subscribe! source (f g))))

(defmacro lens
  "Returns an Observable which intercepts and modifies events from
  source. f is invoked on each observed event from source, and may
  call 'relay' or 'stop' to send events to a downstream subscriber."
  [source f]
  `(let [f# ~f]
     (Lens. ~source (fn [g#]
                      (fn [observation#]
                        (try 
                          (binding [*downstream* g#
                                    *observation* observation#]
                            (f# *observation*))
                          (catch Throwable t#
                            (g# (ObservedError. t#)))))))))

(defn relay
  "Used in the scope of a lens. With no arguments, forwards the
  current event to the downstream subscriber. With one argument, sends
  a new event with that value to the downstream subscriber."
  ([] (*downstream* *observation*))
  ([x] (*downstream* (ObservedEvent. x *observation*))))

(defn stop []
  "Used in the scope of a lens. Unsubscribes from the upstream source
  and sends a nil event to the downstream subscriber."
  (unsubscribe! *observation*)
  (*downstream* nil))

(defn map [f source]
  (lens source
        (fn [obs]
          (if (observe obs)
            (relay (f (accept obs)))
            (stop)))))

(defn filter [f source]
  (lens source
        (fn [obs]
          (if (observe obs)
            (when (f (accept obs))
              (relay))
            (stop)))))

(defn take [n source]
  (let [a (atom n)]
    (lens source
          (fn [obs]
            (let [n (swap! a #(if (neg? %) % (dec %)))]
              (when (pos? n)
                (relay))
              (when (zero? n)
                (relay)
                (stop)))))))

(defn take-while [f source]
  (lens source
        (fn [obs]
          (if (and (observe obs) (f (accept obs)))
            (relay)
            (stop)))))

(deftype MergeObservable [sources]
  Observable
  (subscribe! [this f]
    (let [a (atom (count sources))
          subs (doall
                (clojure.core/map
                 (fn [source]
                   (subscribe! source
                               (fn [obs]
                                 (if (observe obs)
                                   (f obs)
                                   (when (zero? (swap! a dec))
                                     (f nil))))))
                 sources))]
      (reify Subscription
        (unsubscribe! [this]
          (doseq [s subs]
            (unsubscribe! s)))))))

(defn merge [& sources]
  (MergeObservable. sources))

(defn first-in
  "Returns an Observable which relays events from whichever source
  produces an event first."
  [& sources]
  (let [a (atom nil)]
    (apply merge
           (clojure.core/map-indexed
            (fn [i source]
              (lens source
                    (fn [obs]
                      (if (and (observe obs)
                               (= i (swap! a #(if (nil? %) i %))))
                        (relay)
                        (stop)))))
            sources))))

(deftype ObservableFutureCall [call]
  Observable
  (subscribe! [this f]
    (let [fut (future
                (f (try (ObservedEvent. (call) nil)
                        (catch Throwable t
                          (ObservedError. t))))
                (f nil))]
      (reify Subscription
        (unsubscribe! [this]
          (future-cancel fut))))))

(defn observable-future-call
  "Returns an Observable which invokes f in a future and generates one
  event with its return value."
  [f]
  (ObservableFutureCall. f))

(defmacro observable-future
  "Returns an Observable which invokes body in a future and generates
  one event with its return value."
  [& body]
  `(observable-future-call (fn [] ~@body)))

(defn sleep-timer
  "Returns an Observable which sleeps for n milliseconds and then
  generates one event of value."
  [n value]
  (observable-future (Thread/sleep n) value))

(defn debug [x]
  (if (observe x)
    (try (prn :EVENT (accept x))
         (catch Throwable t
           (prn :THROWN t)))
    (prn :DONE)))
