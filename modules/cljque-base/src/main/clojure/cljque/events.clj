(ns cljque.events
  (:refer-clojure :exclude (map filter take take-while merge)))

(defprotocol Observable
  (subscribe! [this f]
    "Invokes f on each event generated by this observable, whenever
    and wherever it occurs.  Returns a Subscription."))

(defprotocol Subscription
  (unsubscribe! [this]
    "Terminates this subscription."))

(defprotocol Observation
  (observe [this]
    "Returns this observation or nil if the end of observable events
    has been reached.")
  (accept [this]
    "Returns the latest event observed, or nil if the end of
    observable events has been reached. Re-throws exceptions thrown by
    the Observable source."))

(extend-type nil
  Observable
  (subscribe! [this f] (future (f nil)))
  Subscription
  (unsubscribe! [this] nil)
  Observation
  (observe [this] nil)
  (accept [this] nil))

(deftype ObservedEvent [event subscription]
  Observation
  (observe [this] this)
  (accept [this] event)
  Observable
  (subscribe! [this g]
    (subscribe! subscription g))
  Subscription
  (unsubscribe! [this]
    (unsubscribe! subscription)))

(deftype ObservedError [throwable]
  Observation
  (observe [this] this)
  (accept [this] (throw throwable)))

(deftype ObservableSeq [s]
  Observable
  (subscribe! [this f]
    (let [open? (atom true)
          sub (reify Subscription
                (unsubscribe! [this] (reset! open? false)))]
      (future
        (try
          (loop [xs s]
            (when (and @open? (seq xs))
              (f (ObservedEvent. (first xs) sub))
              (recur (next xs))))
          (when @open?
            (f nil))
          (catch Throwable t
            (f (ObservedError. t)))))
      sub)))

(declare ^:dynamic *observation* ^:dynamic *downstream*)

(defn relay
  ([] (*downstream* *observation*))
  ([x] (*downstream* (ObservedEvent. x *observation*))))

(deftype Lens [source f]
  Observable
  (subscribe! [this g]
    (subscribe! source (f g))))

(defmacro lens [source f]
  `(let [f# ~f]
     (Lens. ~source (fn [g#]
                      (fn [observation#]
                        (try 
                          (binding [*downstream* g#
                                    *observation* observation#]
                            (f# *observation*))
                          (catch Throwable t#
                            (g# (ObservedError. t#)))))))))

(defn map [f source]
  (lens source
        (fn [obs]
          (if (observe obs)
            (relay (f (accept obs)))
            (relay)))))

(defn filter [f source]
  (lens source
        (fn [obs]
          (if (observe obs)
            (when (f (accept obs))
              (relay))
            (relay)))))

(defn take [n source]
  (let [a (atom n)]
    (lens source
          (fn [obs]
            (when (not (neg? (swap! a #(if (neg? %) % (dec %)))))
              (relay))))))

(deftype MergeObservable [sources]
  Observable
  (subscribe! [this f]
    (let [a (atom (count sources))
          subs (doall
                (clojure.core/map
                 (fn [source]
                   (subscribe! source
                               (fn [obs]
                                 (if (observe obs)
                                   (f obs)
                                   (when (zero? (swap! a dec))
                                     (f nil))))))
                 sources))]
      (reify Subscription
        (unsubscribe! [this]
          (doseq [s subs]
            (unsubscribe! s)))))))

(defn merge [& sources]
  (MergeObservable. sources))

