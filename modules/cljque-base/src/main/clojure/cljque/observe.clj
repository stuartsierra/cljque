(ns cljque.observe
  "The Observer/Observable protocols, with bridges to sequences and IRefs.")

(defprotocol Observable
  (observe [observable observer]
    "Asynchronously subscribes observer to events generated by
    observable.  May have side-effects.  Returns a no-arg function
    which unsubscribes the observer."))

(defprotocol Observer
  (message [observer m]
    "Called when an observable this observer is subscribed to
    generates a message m.  This method must not block; use future or
    send-off for I/O.")
  (done [observer]
    "Called when observable this observer is subscribed to is finished
    generating events.  This method must not block; use future or
    send-off for I/O.")
  (error [observer e]
    "Called when observable this observer is subscribed to throws an
    exception e.  This method must not block; use future or
    send-off for I/O."))

;;; Observable references

(defn observable-iref [iref]
  (reify Observable
    (observe [this observer]
      (let [key (Object.)]
        (add-watch iref key
                   (fn [_ _ old-value new-value]
                     (message observer new-value)))
        (fn [] (remove-watch iref key))))))

;;; Observables and Sequences

(defn observable-seq [s]
  (reify Observable
    (observe [this observer]
      (let [continue (atom true)]
        (future
          (try
            (loop [xs s]
              (when @continue
                (if-let [x (clojure.core/first xs)]
                  (do (message observer x)
                      (recur (next xs)))
                  (done observer))))
            (catch Throwable t
              (error observer t))))
        (fn [] (reset! continue false))))))

(deftype ObservableError [e])

(defn seq-observable [observable]
  (let [q (java.util.concurrent.LinkedBlockingQueue.)
        consumer (fn thisfn []
                   (lazy-seq
                    (let [x (.take q)]
                      (cond
                       (= x ::done) nil
                       (instance? ObservableError x) (throw (.e x))
                       :else (cons x (thisfn))))))]
    (observe observable
             (reify Observer
               (message [this m] (.put q m))
               (done [this] (.put q ::done))
               (error [this e] (.put q (ObservableError. e)))))
    (consumer)))

;;; Agents as Observers

(defn observer-agent [a on-message on-done]
  "Returns an Observer which forwards messages to Agent a:
   When it receives a message m, calls (send a on-message m) ;
   When it receives done, calls (send a on-done) ;
   And when it receives an exception, sends a function which 
   rethrows the exception."
  (reify Observer
    (message [this m] (send a on-message m))
    (done [this] (send a on-done))
    (error [this e] (send a (fn [_] (throw e))))))
